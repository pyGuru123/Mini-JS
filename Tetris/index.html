<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Tetris</title>
	<style type="text/css">
		html, body {
			margin: 0;
			padding: 0;
			background-color: rgb(10,13,18);
		}

		.main {
			top: 50%;
			left: 50%;
			position: absolute;
			transform: translate(-50%, -50%);
			width : 300px;
			height: 500px;
			border: 1px solid rgb(21,24,29);
			background-color: rgb(21,24,29);
		}

		canvas {
			background-color: rgb(21, 24, 29);
			border: 2px solid rgb(217, 217, 217);
		}
	</style>
</head>
<body>
	<div class='main'>
		<canvas class='board' width="300" height="500"></canvas>
	</div>

	<script type="text/javascript">
		const canvas = document.querySelector('canvas');
		const ctx = canvas.getContext('2d');

		const WIDTH = 300;
		const HEIGHT = 500;
		const CELLSIZE = 20;
		const ROWS = (HEIGHT - 120) / CELLSIZE;
		const COLS = WIDTH / CELLSIZE;

		const FIGURES = {
				'I' : [[1, 5, 9, 13], [4, 5, 6, 7]],
		        'Z' : [[4, 5, 9, 10], [2, 6, 5, 9]],
		        'S' : [[6, 7, 9, 10], [1, 5, 6, 10]],
		        'L' : [[1, 2, 5, 9], [0, 4, 5, 6], [1, 5, 9, 8], [4, 5, 6, 10]],
		        'J' : [[1, 2, 6, 10], [5, 6, 7, 9], [2, 6, 10, 11], [3, 5, 6, 7]],
		        'T' : [[1, 4, 5, 6], [1, 4, 5, 9], [4, 5, 6, 9], [1, 5, 6, 9]],
		        'O' : [[1, 2, 5, 6]]
			}

		const TYPES = ['I', 'Z', 'S', 'L', 'J', 'T', 'O']
		const FPS = 24;

		// Canvas Update *****************************************************

		let tetris = new Tetris(ROWS, COLS);
		tetris.new_figure();

		let counter = 0;
		let move_down = false;
		let can_move = true;

		function updateCanvas() {
			ctx.clearRect(0, 0, WIDTH, HEIGHT);
			drawGrid();

			counter += 1;
			if (counter > 10000) {
				counter = 0
			}

			if (can_move) {
				if (counter % (FPS / (tetris.level*2))) {
					if (!tetris.gameover) {
						tetris.go_down();
					}
				}
			}


		}

		var interval = setInterval(updateCanvas, 10);
		document.addEventListener('keydown', keyDown);
		document.addEventListener('keyup', keyUp);

		// Event Handling ****************************************************

		function keyDown(event) {
			if (event.key == 'ArrowLeft') {
				tetris.go_side(-1);
			}
			if (event.key == 'ArrowRight') {
				tetris.go_side(1);
			}
			if (event.key == 'ArrowUp') {
				tetris.rotate();
			}
			if (event.key == 'ArrowDown') {
				move_down = true;
			}
			if (event.key == ' ') {
				print('yes')
				tetris.go_space();
			}
			print(event.key, event.keyCode)
		}

		function keyUp() {
			if (event.key == 'ArrowDown') {
				move_down = false;
			}
		} 

		// Objects ***********************************************************

		function Tetramino(x, y) {
			this.x = x;
			this.y = y;
			this.type = TYPES[random(TYPES.length-1)];
			this.shape = FIGURES[this.type]
			this.color = random(1, 4);
			this.rotation = 0;

			this.image = function() {
				return this.shape[this.rotation];
			}

			this.rotate = function() {
				this.rotation = (this.rotation + 1) % this.shape.length;
			}
		}

		function Tetris(rows, cols) {
			this.rows = rows;
			this.cols = cols;
			this.score = 0;
			this.level = 1;
			this.board = createBoard();
			this.next = null;
			this.gameover = false;

			this.new_figure = function() {
				if (this.next == null){
					this.next = new Tetramino(5, 0);
				}

				this.figure = this.next;
				this.next = new Tetramino(5, 0);
			}

			this.intersects = function() {
				intersection = false;
				for (let i=0; i<4; i++) {
					for (let j=0; j<4; j++) {
						if (this.figure.image().includes(i*4+j)) {
							if ((i+this.figure.y > this.rows-1) ||
							   (j+this.figure.x > this.cols-1) ||
							   (j+this.figure.x < 0) ||
							   (this.board[i + this.figure.y][j + this.figure.x] > 0)) {
							   		intersection = true;
						   }
						}
					}
				}
				return intersection;
			}

			this.removeLine = function() {
				var rerun = false;
				for (let y=ROWS-1; y>0; y--) {
					var is_full = true;
					for (let x=0; x<COLS-1; x++) {
						if (this.board[y][x] == 0) {
							is_full = false;
						}
					}
					if (is_full) {
						this.board.splice(y, 1);
						this.board.unshift(createArray());
						this.score += 1;
						if (this.score % 10 == 0) {
							this.level += 1
						} 
						rerun = true;
					}
				}
				if (rerun) {
					this.removeLine();
				}

			}

			this.freeze = function() {
				for (let i=0; i<4; i++) {
					for (let j=0; j<4; j++) {
						if (this.figure.image().includes(i*4+j)) {
							this.board[i+this.figure.y][j+this.figure.x] = this.figure.color;
						}
					}
				}
				this.removeLine();
				this.new_figure();
				if (this.intersects()) {
					this.gameover = true;
				}
			}

			this.go_space = function() {
				while (!this.intersects()) {
					this.figure.y += 1;
				}
				this.figure.y -= 1;
				this.freeze();
			}

			this.go_down = function() {
				this.figure.y += 1;
				if (this.intersects) {
					this.figure.y -= 1;
					this.freeze();
				}
			}

			this.go_side = function(dx) {
				this.figure.x += dx;
				if (this.intersects()) {
					this.figure.x -= 1;
				}
			}

			this.rotate = function() {
				rotation = this.figure.rotation;
				this.figure.rotate();
				if (this.intersects()) {
					this.figure.rotation = rotation;
				}
			}
		}

		// Functions *********************************************************

		function drawLine(x1, y1, x2, y2) {
			ctx.strokeStyle = 'red';
			ctx.beginPath();
			ctx.moveTo(x1, y1);
			ctx.lineTo(x2, y2);
			ctx.stroke();
		}

		function drawGrid() {
			for (let i=0; i<ROWS+1; i++) {
				drawLine(0, CELLSIZE*i, WIDTH, CELLSIZE*i);
			}
			for (let j=0; j<COLS; j++) {
				drawLine(CELLSIZE*j, 0, CELLSIZE*j, HEIGHT-120);
			}
		}

		function createArray() {
			array = []
			for (let i=0; i<COLS; i++){
				array[i] = 0;
			}
			return array
		}

		function createBoard() {
			var board = [];
				for (let i=0; i<ROWS; i++) {
					board.push(createArray());
				}
			return board;
		}

		function random(min, max) {
			if (arguments.length == 1) {
				max = arguments[0] + 1;
				min = 0;
			}
			return Math.floor(Math.random() * (max)) + min
		}

		function print() {
			for (value of arguments) {
				console.log(value);
			}
		}
	</script>
</body>
</html>